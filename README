GoVM
----



	1. VM Instructions



1.1 Dictionary


reg - Register
lit - Literal
add - Code address
dat - Data address

Note that except for hlt being represented by 0.0, no other instruction
has its value specified.
Also, `a` refers to the value of the first argument and `b` refers to the
value of the second argument, whenever applicable.



1.2 Instructions


hlt
	Halts program execution
nop
	Does nothing.

val	[lit]	[reg]
	Sets b to be equal to a.
cpy	[reg]	[reg]
	Sets b to be equal to a.
psh	[reg]
	Pushes a to the top of the stack.
pop	[reg]
	Pops the top of the stack into a.

add	[reg]	[reg]
	Adds a to b.
sub	[reg]	[reg]
	Subtracts a from b.
mul	[reg]	[reg]
	Multiplies a to b.
div	[reg]	[reg]
	Divides b by a.

inc	[reg]
	Increases a by 1.
dec	[reg]
	Decreases a by 1.
flr	[reg]
	Changes a to the highest integer value lower or equal than a.
cel	[reg]
	Changes a to the lowest integer value higher or equal than a.

shw	[reg]
	Prints the a to the standard output.
get	[reg]
	Sets a to whatever is entered into the standard input (if valid).
dsp	[dat]
	Prints the a-th string to the standard output.

cmp	[reg]	[reg]
	If a is less than b, flt is set to true. If a equals b, feq is set
	to true. Otherwise, fgt is set to true. When a flag is set to true
	the other flags are set to false.
cmz	[reg]
	Same behavior as cmp assuming there is a second argument where b
	equals zero.

jmp	[add]
	Jumps to the a-th instruction.
jgt	[add]
	Jumps to the a-th instruction if the fgt flag is set to true.
jeq	[add]
	Jumps to the a-th instruction if the feq flag is set to true.
jlt	[add]
	Jumps to the a-th instruction if the flt flag is set to true.

cll	[add]
	Jumps to the a-th instruction and saves current instruction index
	plus two (the next instruction) into the call stack.
ret
	Let n be the topmost value in the call stack. Jumps to the n-th
	instruction and pops the call stack.

	2. Syntax



2.1 Registers


All registers are written as %n where n is an *integer* referring to the
n-th register.



2.2 Comments


Any text after an instruction and its arguments is a valid comment.
Please mind that str pseudo-instructions consume everything so don't
comment on those lines.

Examples:

nop Hey jude.
add %0	%1 Don't say goodbye.



2.3 Jump statements


Jump statements have special syntax so that people don't have to manually
count the number of instructions. For this purpose a pseudo-instruction is
introduced.

Labels are defined by

lab <labelname>

and jump statements are written as

j** <labelname>

and what they do is fairly intuitive.

Label redefinition is a compilation error.

Also, jumps to labels that preceed no instruction or preceed the first
instruction is currently undefined behavior to make my life easier and
they're unecessary.

2.4 Constant strings

String syntax also has special pseudo-instructions. 

str	<name>	...

Basically sets <name> to represent the index a string made of every word after
it's name but separated by a space.
I don't know what happens if there's nothing but whitespace after <name>, since
I have not implemented this yet. PS: It's just newline.
To display a string, you use

dsp	<name>

so that you don't have to know by heart all of the string indexes.
The <name> used in a dsp instruction has to be already declared by a str.
If you don't it will be actually set as 0, so as long as you defined at
least one string, the first one will be defaulted to.

2.5 Function calls

A function name is defined as def, which really does nothing* besides act just
like lab. In the future it may do some special stuff/add special behavior.
*Actually the difference between def and lab is that def is always resolved after
parsing the entire file since that's what I'll recommend in the third paragraph
of this subsection.

The two new instructions are cll and ret, which make use of the call stack to
know where to return.

Here's the gist. Function bodies are just parsed as normal instructions, so if
a the body of the function gets reached it will be executed normally except the
ret statement will make things go bad. So write them after everything else and
make sure the program halts before reaching that.

